<p align="center">
  <img src="https://www.d.umn.edu/~gshute/softeng/new/design_patterns/images/list.png" alt="HttpPatch" width="500"/>
</p>

# Design Patterns
The project includes examples of implementation of Design Patterns by GOF using C# and UML diagrams

Design Patterns can be classified into three categories namely
	- Creational patterns
	- Structural patterns
	- Behavioral patterns

1. [Creational design patterns](https://en.wikipedia.org/wiki/Creational_pattern)
 - are design patterns that deal with object creation mechanisms, trying to create objects in a manner suitable to the situation.
 - creational patterns consists of five design patterns
 	
	* [Abstract factory](https://en.wikipedia.org/wiki/Abstract_factory_pattern) - which provides an interface for creating related or dependent objects without specifying the objects' concrete classes
						
	* [Builder](https://en.wikipedia.org/wiki/Builder_pattern) - separate the construction of a complex object from its representation so that the same construction process can create different representations

	* [Factory method](https://en.wikipedia.org/wiki/Factory_method_pattern) - centralize creation of an object of a specific type choosing one of several implementations
								
	* [Singleton](https://en.wikipedia.org/wiki/Singleton_pattern) - restrict instantiation of a class to one object

	* [Prototype](https://en.wikipedia.org/wiki/Prototype_pattern) - used when the type of objects to create is determined by a prototypical instance, which is cloned to produce new objects

2. [Structural design patterns](https://en.wikipedia.org/wiki/Structural_pattern)
 - are design patterns that ease the design by identifying a simple way to realize relationships between entities.

- examples of structural design patters includes the following
	
	* [Adapter](https://en.wikipedia.org/wiki/Adapter_pattern) - match interfaces of different classes or 'adapts' one interface for a class into one that a client expects

	* [Bridge](https://en.wikipedia.org/wiki/Bridge_pattern) - decouple an abstraction from its implementation so that the two	can vary independently

	* [Composite](https://en.wikipedia.org/wiki/Composite_pattern) - a tree structure of objects where every object has the same interface
						
	* [Decorator](https://en.wikipedia.org/wiki/Decorator_pattern) - add additional functionality to a class at runtime where subclassing would result in an exponential rise of new classes

	* [Facade](https://en.wikipedia.org/wiki/Facade_pattern) - create a simplified interface of an existing interface to ease usage for common tasks

	* [Flyweight](https://en.wikipedia.org/wiki/Flyweight_pattern) - a large quantity of objects share a common properties object to save space
						
	* [Proxy](https://en.wikipedia.org/wiki/Proxy_pattern) - An object representing another object or a class functioning as an interface to something else
					
3. [Behavioral design patterns](https://en.wikipedia.org/wiki/Behavioral_pattern)
 - are design patterns that identify common communication patterns between objects and 	 realize these patterns.

 - examples of behavioral design patterns comprise of the following

	* [Chain of Responsibility](https://en.wikipedia.org/wiki/Chain_of_responsibility_pattern) - command objects are handled or passed on to other objects by logic-containing processing objects
						
	* [Commmand](https://en.wikipedia.org/wiki/Command_pattern) - command objects encapsulate an action and its parameters

	* [Interpreter](https://en.wikipedia.org/wiki/Interpreter_pattern) - a way to include language elements in a program

	* [Iterator](https://en.wikipedia.org/wiki/Iterator_pattern) - iterators are used to access the elements of an aggregate object sequentially without exposing its underlying representation

	* [Mediator](https://en.wikipedia.org/wiki/Mediator_pattern) - provides a unified interface to a set of interfaces in a subsystem

	* [Memento](https://en.wikipedia.org/wiki/Memento_pattern) - provides the ability to restore an object to its previous state (rollback)
					
	* [Observer](https://en.wikipedia.org/wiki/Observer_pattern) - objects register to observe an event that may be raised by another object

	* [State](https://en.wikipedia.org/wiki/State_pattern) - a clean way for an object to partially change its type at runtime

	* [Strategy](https://en.wikipedia.org/wiki/Strategy_pattern) - algorithms can be selected on the fly

	* [Template method](https://en.wikipedia.org/wiki/Template_method_pattern) - defer the exact steps of an algorithm to a subclass

	* [Visitor](https://en.wikipedia.org/wiki/Visitor_pattern) - a way to separate an algorithm from an object
