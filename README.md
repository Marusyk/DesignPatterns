# Design Patterns
The project includes examples of implementation of Design Patterns by GOF using C# and UML diagrams

Design Patterns can be classified into three categories namely
	- Creational patterns
	- Structural patterns
	- Behavioral patterns


1. Creational design patterns
 - are design patterns that deal with object creation mechanisms, trying to create objects in a manner suitable to the situation.
 https://en.wikipedia.org/wiki/Creational_pattern

 - creational patterns consists of five design patterns
 	
	* Abstract factory pattern - which provides an interface for creating related or 
						dependent objects without specifying the objects' concrete classes
						https://en.wikipedia.org/wiki/Abstract_factory_pattern
						
	* Builder pattern - separate the construction of a complex object from its 
					representation so that the same construction process can create
						different representations
						https://en.wikipedia.org/wiki/Builder_pattern

	* Factory method pattern - centralize creation of an object of a specific type
								choosing one of several implementations
								https://en.wikipedia.org/wiki/Factory_method_pattern

	* Singleton pattern - restrict instantiation of a class to one object
							https://en.wikipedia.org/wiki/Singleton_pattern

	* Prototype pattern - used when the type of objects to create is determined by a
						prototypical instance, which is cloned to produce new objects
						https://en.wikipedia.org/wiki/Prototype_pattern

2. Structural design patterns
 - are design patterns that ease the design by identifying a simple way to realize
 	relationships between entities.
	https://en.wikipedia.org/wiki/Structural_pattern

- examples of structural design patters includes the following
	
	* Adapter pattern - match interfaces of different classes or 'adapts' one
						interface for a class into one that a client expects
						https://en.wikipedia.org/wiki/Adapter_pattern

	* Bridge pattern - decouple an abstraction from its implementation so that the 
						two	can vary independently
						https://en.wikipedia.org/wiki/Bridge_pattern

	* Composite pattern - a tree structure of objects where every object has the 
						same interface
						https://en.wikipedia.org/wiki/Composite_pattern

	* Decorator pattern - add additional functionality to a class at runtime where 
					subclassing would result in an exponential rise of new classes
					https://en.wikipedia.org/wiki/Decorator_pattern

	* Facade pattern - create a simplified interface of an existing interface to 
						ease usage for common tasks
						https://en.wikipedia.org/wiki/Facade_pattern

	* Flyweight pattern - a large quantity of objects share a common properties 
						object to save space
						https://en.wikipedia.org/wiki/Flyweight_pattern

	* Proxy pattern - An object representing another object or a class functioning 
					as an interface to something else
					https://en.wikipedia.org/wiki/Proxy_pattern

3. Behavioral design patterns
 - are design patterns that identify common communication patterns between objects and 	 realize these patterns.
   https://en.wikipedia.org/wiki/Behavioral_pattern

 - examples of behavioral design patterns comprise of the following

	* Chain of Responsibility pattern - command objects are handled or passed on to 
							other objects by logic-containing processing objects
						https://en.wikipedia.org/wiki/Chain_of_responsibility_pattern

	* Commmand pattern - command objects encapsulate an action and its parameters
						https://en.wikipedia.org/wiki/Command_pattern

	* Interpreter pattern - a way to include language elements in a program
							https://en.wikipedia.org/wiki/Interpreter_pattern

	* Iterator pattern - iterators are used to access the elements of an aggregate 
				object sequentially without exposing its underlying representation
				https://en.wikipedia.org/wiki/Iterator_pattern

	* Mediator pattern - provides a unified interface to a set of interfaces in a 
						subsystem
						https://en.wikipedia.org/wiki/Mediator_pattern

	* Memento pattern - provides the ability to restore an object to its previous 
					state (rollback)
					https://en.wikipedia.org/wiki/Memento_pattern

	* Observer pattern - objects register to observe an event that may be raised by 
					another object
					https://en.wikipedia.org/wiki/Observer_pattern

	* State pattern - a clean way for an object to partially change its type at 
					runtime
					https://en.wikipedia.org/wiki/State_pattern

	* Strategy pattern - algorithms can be selected on the fly
						https://en.wikipedia.org/wiki/Strategy_pattern

	* Template method pattern - defer the exact steps of an algorithm to a subclass
							https://en.wikipedia.org/wiki/Template_method_pattern

	* Visitor pattern - a way to separate an algorithm from an object
						https://en.wikipedia.org/wiki/Visitor_pattern
